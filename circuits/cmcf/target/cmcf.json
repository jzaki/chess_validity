{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":10880675505199346571,"abi":{"parameters":[{"name":"x1","type":{"kind":"field"},"visibility":"private"},{"name":"y1","type":{"kind":"field"},"visibility":"private"},{"name":"x2","type":{"kind":"field"},"visibility":"private"},{"name":"y2","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"zZ3dThtJEIXfxddcdP10dxWvslpFhJDIkmUiICutEO++w8KYyM1ilbzVnJtIE7qLTz4+34DtFo+bbzdff/34st1/v73fXP7xuNndXl89bG/3y9Xjpvz7X/c/r/bPV/cPV3cPm0vu9WJzs/+2uRTqTxeb79vdzeay09PFuFT761Ju7W1pefrzYkOJszlxtiTO1sTZNXF2S5zdE2db4mzP7E5qMTObSZnVpMxuUmY5KbOdlFlPyuwnZRaUMhvKmQ3l1HtnZkM5s6Gc2VDObChnNpQzG8qZDeXMhkpmQyWzoZL6421mQyWzoZLZUMlsqGQ2VDIbKpkN1cyGamZDNbOhmvobaGZDNbOhmtlQzWyoZjZU/8eGWjkaXkvmcMoczpnDz22o0jpcxY6Ha+bwmjn83IZqbevwRsfDz22oenldWmkYbpnDPXF4K5nDz21oZV6HV/l9+LjU2V6XetVjDgbhEBAOBeGo8zioVHldS6UPJA2GpMOQGAyJo5D0AkNCMCQMQyIwJApDAuPYDuPYDuPYDuPYDuNYg3GswTjWYBxrMI41GMcajGMNxrEG41iDcazBONZhHOswjnUYxzqMYx3GsQ7jWIdxrMM41mEc6zCOpQIjWSqfZVmzAYVxUAQHZaZoF5YVhWT87OhM05KvLw8Tlz6gNByUjoNiOCgzbcv18LTlzscoVHBQZtpWyyEg5TqgMA6K4KAoDkrFQWk4KB0HxXBQHAaFCw4Kjm0Zx7aMY1vGsS3j2JZxbMs4tmUc2zKObQXHtoJjW8GxreDYVnBsKzi2FRzbCo5tBce2gmNbxbGt4thWcWyrOLZVHNvqZ9lWfEBpOCgdB2WqbVs5oDgNKDNtW4VWlKrHZ2GoFhwUwkFhHBTBQVEclJm2rdYOKGOZ60zb9rKupS7DOx+146AYDspM21rVFcXacA9qBQeFcFAYB2Wmba0fULzIgKI4KBUHpeGg9KlPW3lDGT5gNPWw2AmUmbZ1OdyZvQ4BTT0udgKFcFAYB0VwUBQHpeKgNByUjoNiOCg4tjUc2xqObQ3HtoZjW8OxreHY1nBsazi2NRzbGo5tHce2jmNbx7Gt49jWcWzrOLZ1HNs6jm0dx7YOY1suMLblAmNbLjC25fJZtm11QFEclIqD0nBQOg6K4aA4DAoVHBTCQZlo2+WJuX5+ZUnDBxTBQVEclIqDMtG2yzfjA4rRgNJxUAwHxWFQZp4lO4VCOCiMgyI4KIqDUnFQcGzLOLZlHNsyjm0Fx7aCY1vBsa3g2FZwbCs4thUc2wqObQXHtoJjW8WxreLYVnFsqzi2VRzbKo5tFce2imNbxbGt4ti24ti2fpZtfXhrqjIOiuCgKA5KxUGZadvltfMVZenLgNJxUGbaln0du/yCXAYUh0GZeZbsFArhoJxt2+Yrio/TJXW6pk6vqdPPNVcr63nfJnriKVBlPYG0GPPEYuf1jTKvb0dDpb9Q95nU/fA3Kavx8ACeK7nWVoe2o3ONy8XXu+1ut/3xZXd7ffWwvd3fP28sz/+8fyO2w+lr++0BfnnU3r9ffrijhXf08A4L7/DojveV++EOCu/g8A4J7whn3sKZt3DmLZx5C2fewpn3cOY9nHkPZ97Dmfdw5j2ceQ9n3sOZ93DmPZy5hTO3cOYWztzCmVs4cwtnbuHMLZy5hTO3cOYeztzDmXs4cw9n7uHMPZy5hzP3cOYeztzDmf/H3wj5eAvFt3B8i8S3aHxLjW9p8S09vsXiW+LpUzx9iqdP8fQpnj7F06d4+hRPn+LpUzx9iqfP8fQ5nj7H0+d4+hxPn+Ppczx9jqfP8fQ5nr7E05d4+hJPX+LpSzx9iacv8fQlnr4E039arv66uttefd3dPL+o8fzFX/vr9TWO5fLh758vX1kW/wM=","file_map":{"37":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod schnorr;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod eddsa;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod ec;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(\n        crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y),\n    )\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"70":{"source":"pub mod pieces;\n\nuse pieces::{Piece, Board};\n\npub struct Position {\n    pub x: Field,\n    pub y: Field,\n}\n\npub struct Move {\n    pub start: Position,\n    pub end: Position\n}\n\npub fn is_valid_move(board: Board, move: Move) {\n    let piece: Piece = board[move.start.y][move.start.x];\n\n    if piece.black == true {\n        // unconstrained inversion\n        // constrained verification?\n    }\n\n    // white moves\n    if piece.piece_type == 0 {\n        assert(false, \"No piece\");\n    } else if piece.piece_type == 1 {\n        is_valid_pawn_move(board, move);\n    } else if piece.piece_type == 2 {\n        is_valid_knight_move(board, move);\n    } else {\n        assert(false, \"Other pieces not implemented\");\n    }\n}\n\nglobal MAX_FIELD_VALUE: Field =\n    21888242871839275222246405745257275088548364400416034343698204186575808495616;\n\n// \n// o\n// |\n// o X\n// |/\n// P x\n// \npub fn is_valid_pawn_move(board: Board, move: Move) {\n    if move.start.x == move.end.x { // moving forward uncollided\n\n        // nothing one square ahead\n        let piece_one_ahead = board[move.start.y+1][move.start.x];\n        assert(piece_one_ahead.piece_type == 0);\n\n        let step = move.end.y - move.start.y;\n\n        if step == 2 { // step forward 2 squares\n            assert(move.start.y == 1, \"Double step from first row only\"); // from first row only\n            // nothing two squares ahead\n            let piece_two_ahead = board[move.end.y][move.start.x];\n            assert(piece_two_ahead.piece_type == 0, \"Path obstructed\");\n        } else if step != 1 { // backward or non-step\n            assert(false, \"Should step by 1\");\n        }\n    } else { // capture (diagonal move, capture or en passant)\n        assert(move.end.y - move.start.y == 1); // one step forward\n        let step_right = move.end.x - move.start.x;\n\n        // left or right by 1\n        assert((step_right == 1) | (step_right == MAX_FIELD_VALUE));\n\n        let capture_piece = board[move.end.y][move.end.x];\n        if capture_piece.black == true { // capture diagonal\n            // successful capture\n        } else if capture_piece.piece_type == 0 { // possibly en passant\n            let ep_piece = board[move.start.y][move.end.x];\n            assert(Piece::Eq(ep_piece,Piece::pawn(true))); // captured pawn\n        }\n    }\n\n    if move.end.y == 7 { // promotion\n        //todo\n    }\n    \n}\n\n// \n//    x   x\n//     \\ /\n//x-.-. | .-.-x\n//     \\|/\n//      K\n//     /|\\\n//x-.-. | .-.-x\n//     / \\\n//    x   x\n// \npub fn is_valid_knight_move(board: Board, move: Move) {\n    println(\"is_valid_knight_move\");\n    assert(false, \"Not implemented\");\n}\n","path":"/home/jz/Documents/code/aztec/chess_validity/circuits/cmcf/src/chess.nr"},"71":{"source":"mod chess;\n\nuse chess::{Position, Move, is_valid_move, pieces};\n\n\nfn main(x1: Field, y1: Field, x2: Field, y2: Field) {//, board: [[Field; 8]; 8]) {\n    let start = Position { x: x1, y: y1 };\n    let end = Position { x: x2, y: y2 };\n\n    let move = Move { start, end };\n\n    is_valid_move(pieces::start_board(), move);\n}\n\n\n#[test]\nfn test_pawn_start() {\n    main(5, 1,5, 3);\n    // main(1, 0, 2, 2);\n\n    // Uncomment to make test fail\n    // main(1, 1);\n}\n","path":"/home/jz/Documents/code/aztec/chess_validity/circuits/cmcf/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","directive_invert"]}